# 8-Puzzle Solver

## Overview
The 8-Puzzle Solver is a Python program that provides solutions to the classic 8-puzzle problem using various search algorithms. The 8-puzzle problem involves rearranging tiles in a 3x3 grid to reach a goal state from an initial state, with one tile left empty for movement. The program explores different search algorithms to find the optimal solution and provides insights into their time and memory efficiency.

## Problem Description
The 8-puzzle consists of a 3x3 grid containing tiles numbered from 1 to 8 and an empty space (represented as 0). The goal is to move the tiles in the grid to reach a target arrangement. Tiles can be moved either up, down, left, or right, one space at a time.

## Algorithms
The program implements the following search algorithms to solve the 8-puzzle problem:

### 1. Depth-First Search (DFS)
DFS explores as far as possible along a branch before backtracking. It may not always find the optimal solution and can be slow in certain cases.

### 2. Breadth-First Search (BFS)
BFS explores all vertices at the same level before moving on to the next level. It is guaranteed to find the optimal solution but can be memory-intensive.

### 3. Iterative Deepening Search (IDS)
IDS combines the benefits of DFS and BFS by incrementally increasing the depth limit of the search until a solution is found. It balances time complexity and solution quality.

### 4. Uniform Cost Search (UCS)
UCS finds the shortest path from a source node to a goal node in a weighted graph. It explores nodes with the lowest cost first.

### 5. A* Search
A* search combines the strengths of BFS and Greedy Best-First Search. It uses a heuristic function to estimate the total cost and finds the path with the lowest cost.

## Heuristic Function
The Manhattan distance is used as the heuristic function in A* search. This function calculates the total number of moves required to move each tile to its final position.

## Usage
1. Import required libraries: `tracemalloc`, `time`, `sys`, `collections`, and `heapq`.
2. Run the program to solve the 8-puzzle problem using various search algorithms.
3. The program will generate output files containing action sequences, time taken, and memory usage for each search algorithm.

## Output
The program creates several output files:
- `output_easy.txt`: Contains action sequences and resource allocations (time and memory) for each puzzle solved by different search algorithms.
- `results_easy.csv`: A CSV file summarizing the time and memory usage for each algorithm on easy puzzles.
- `results_medium.csv`: A CSV file summarizing the time and memory usage for each algorithm on medium puzzles.
- `results_hard.csv`: A CSV file summarizing the time and memory usage for each algorithm on hard puzzles.

## Conclusions
- BFS is guaranteed to find the optimal solution but can be memory-intensive.
- DFS may not find the optimal solution and can be slow.
- IDS balances time complexity and solution quality for puzzles like the 8-puzzle.
- UCS and A* algorithms are efficient and often find the optimal solution quickly.
- The choice of heuristic function in A* greatly impacts performance.
- A* is the recommended algorithm for solving 8-puzzle problems due to its efficiency and optimality.

## Average Resources Used
The program provides average resource usage statistics for easy, medium, and hard puzzles in the respective CSV files.

For more details, please refer to the specific output files generated by the program.
